---
title: "admixr - tutorial"
author: "Martin Petr"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```







This vignette describes how to calculate various population admixture
statistics ($D$, $f_4$, etc.) using the `admixr` package, and how to use it to
do simple filtering and processing of EIGENSTRAT datasets.

**A friendly warning**: many of the statistics implemented here can be quite
sensitive to assumptions about population histories or to errors in the data
(causiing spurious correlations between similarly processed samples, especially
in case of ancient DNA). If you want to use these methods, you should really
understand the theory behind them first! I highly recommend reading Benjamin
Peter's [wonderful
overview](http://www.genetics.org/content/early/2016/02/03/genetics.115.183913)
of the subject and Nick Patterson's [original ADMIXTOOLS
paper](http://www.genetics.org/content/192/3/1065).



## Introduction

[ADMIXTOOLS](https://github.com/DReichLab/AdmixTools/) is a widely used
software package for calculating admixture statistics and testing population
admixture hypotheses. However, although powerful and comprehensive, it is not
exactly known for being user-friendly.

A typical ADMIXTOOLS workflow often involves a combination of `sed`/`awk`/shell
scripting and manual editing to create different configuration files. These are
then passed as command-line arguments to one of ADMIXTOOLS commands, and
control how to run a particular analysis. The results are then redirected to
another file, which has to be parsed by the user to extract values of interest,
often using command-line utilities again or (worse) by manual copy-pasting.
Finally, the processed results are analysed in R, Excel or another program.

This workflow is very cumbersome, especially if one wants to explore many
hypotheses involving different combinations of populations. Most importantly,
however, it makes it difficult to follow the rules of best practice for
reproducible science, as it is nearly impossible to construct reproducible
automated "pipelines".

This R package makes it possible to perform all stages of an ADMIXTOOLS
analysis entirely from R. It provides a set of convenient functions that
completely remove the need for "low level" configuration of individual
ADMIXTOOLS programs, allowing users to focus on the analysis itself.










## Installation

**Note that in order to use the `admixr` package, you need a working
installation of ADMIXTOOLS!** You can find installation instructions
[here](https://github.com/DReichLab/AdmixTools/blob/master/README.INSTALL).

**Furthermore, you need to make sure that R can find ADMIXTOOLS binaries on the
`$PATH`.** If this is not the case, running `library(admixr)` will show a
warning message with instructions on how to fix this.

To install `admixr` from GitHub you need to install the package `devtools`
first. To do this, you can simply run (in R):

```{r, eval = FALSE}
install.packages("devtools")
devtools::install_github("bodkan/admixr")
```

Furthermore, if you want to follow the examples in this vignette, you will need
the [tidyverse](https://www.tidyverse.org) collection of packages for
convenient data analysis, which you can install with:

```{r, eval = FALSE}
install.packages("tidyverse")
```

When everything is ready, you can run the following code to make functions in
both packages available:

```{r libraries}
library(admixr)
library(tidyverse)
```





## A note about EIGENSTRAT format

ADMIXTOOLS software uses a peculiar set of genetic file formats, which may seem
strange if you are used to working with [VCF
files](http://samtools.github.io/hts-specs/VCFv4.3.pdf). However, the basic
idea remains the same - we want to store and access SNP data (REF/ALT alleles)
of a set of individuals at a defined set of genomic positions.

EIGENSTRAT datasets always contain three kinds of files:

- `ind` file - specifies the name, sex and population assignment of each sample
- `snp` file - specifies the positions of SNPs, REF/ALT alleles etc.
- `geno` file - contains SNP data (one row per site, one columne per sample) in
  a dense string-based format:
  - 0: individual is homozygous ALT
  - 1: individual is a heterozygote
  - 2: individual is homozygous REF
  - 9: missing data
  
As you can see, a VCF file is essentially a combination of all three files in a
single file. Luckily for us, all three EIGENSTRAT files usually share a common
path and prefix (at least you should try to make it so whenever you work with
them). This allows us to work with just the prefix instead of worrying about
individual files for every analysis.

As such, all main `admixr` functions accept a `prefix` argument, which
specifies the path and prefix of all three EIGENSTRAT files (you can still work
with individual files if you need to - using `ind`, `snp` and `geno` arguments
of each `admixr` function - but try to avoid that because it makes your code
mode verbose).

Let's first download a small testing SNP dataset using a built-in `admixr`
function. We will be using this dataset in the rest of this vignette. For our
convenience, the function returns a prefix of the whole dataset for future
reference. (The function downloads the data into a temporary directory, feel
free to change the final destination using it's `dirname` parameter).

```{r eigenstrat_path}
(eigenstrat_prefix <- download_data(dirname = tempdir()))
```
We can verify that there are three files with this prefix:

```{r eigenstrat_trio}
dir(path = dirname(eigenstrat_prefix), full.names = TRUE)
```

Let's look at their contents:

#### `ind` file
```{r ind_file, echo = FALSE}
cat(system(paste0("column -t ", eigenstrat_prefix, ".ind"), intern = TRUE), sep = "\n")
```

The first column (sample name) and the third column (population label) are
generally not the same (sample names often have numerical suffixes, etc.), but
we kept them the same for simplicity. Importantly, when specifying
population/sample arguments in `admixr` functions, the information in the third
column is what is used. For example, if you have individuals such as "French1",
"French2", "French3" in the first column of an `ind` file, all three sharing a
"French" population label in the third column, specifying "French" in an
`admixr` function will combine all three samples in a single population and
work with it as a whole.

#### `snp` file (first 3 lines)
```{r snp_file, echo = FALSE}
cat(system(paste0("head -n 3 ", eigenstrat_prefix, ".snp"), intern = TRUE), sep = "\n")
```

#### `geno` file (first 3 lines)
```{r geno_file, echo = FALSE}
cat(system(paste0("head -n 3 ", eigenstrat_prefix, ".geno"), intern = TRUE), sep = "\n")
```










## Philosophy of `admixr`

The goal of `admixr` is to make ADMIXTOOLS analyses as trivial to perform as
possible, without having to worry about par/pop/left/right configuration files
(as they are known in ADMIXTOOLS' jargon) and other low-level details.

The only interface between you and ADMIXTOOLS is the following set of R
functions:

- `d()`
- `f4()`
- `f4ratio()`
- `f3()`
- `qpAdm()`

Anything that would normally require [dozens of lines of shell
scripts](https://gaworkshop.readthedocs.io/en/latest/contents/06_f3/f3.html)
can be often accomplished by running a single line of R code.









The following couple of sections describe the usage of `admixr` on a set of
example analyses that one might be interested in doing.








## $D$ statistic

Let's say we are interested in the following question: _"Which populations
today show evidence of Neanderthal admixture?_

One way of looking at this is using the following D statistic:
$$D(\textrm{present-day human W}, \textrm{African}, \textrm{Neanderthal}, \textrm{Chimp}).$$

$D$ statistics are based on comparing the proportions of BABA and ABBA sites
patterns observed in data:

$$D = \frac{\textrm{# BABA sites - # ABBA sites}}{\textrm{# BABA sites + # ABBA sites}}.$$

Significant departure of $D$ from zero indicates an excess of allele sharing
between the first and the third population (positive $D$), or an excess of
allele sharing between the second and the third population (negative $D$). If
we get $D$ that is not significantly different from 0, this suggests that the
first and second populations form a clade, and don't differ in their genetic
affinity to the third population (this is the null hypothesis that the data is
compared against).

Therefore, our $D$ statistic above simply tests whether some modern humans
today admixed with Neanderthals, which would increase their genetic affinity to
this archaic group compared to West Africans (whose ancestors never met
Neanderthals).

Let's save the population names first to make the code below more readable:

```{r pop_def1}
pops <- c("French", "Sardinian", "Han", "Papuan", "Khomani_San", "Mbuti", "Dinka")
```

Using the `admixr` package we can then calculate the $D$ statistic above simply
by running:

```{r d}
result <- d(W = pops, X = "Yoruba", Y = "Vindija", Z = "Chimp", prefix = eigenstrat_prefix)
```

The result is a following `data.frame`:
```{r eval = FALSE}
head(result)
```

```{r d_kable, echo = FALSE}
knitr::kable(head(result))
```

We can see that in addition to the input information, this `data.frame`
contains additional columns:

- `D` - $D$ statistic value
- `stderr` - standard error of the $D$ statistic calculated using the block
  jackknife
- `Zscore` - $Z$-zscore value (number of standard errors the $D$ is from 0,
  i.e. how strongly do we reject the null hypothesis of no admixture)
- `BABA`/`ABBA` - counts of observed site patterns
- `nsnps` - number of SNPs used for a give calculation

(Output tables from other `admixr` functions follow a very similar format.)

While we could certainly make some inferences by looking at the $Z$-scores,
tables in general are not the best representation of this kind of data,
especially as the number of samples increases. This is how we can use the
[`ggplot2`](https://ggplot2.tidyverse.org) package to plot the results:

```{r d_plot, fig.width = 7, fig.height = 4}
ggplot(result, aes(fct_reorder(W, D), D, color = abs(Zscore) > 2)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_errorbar(aes(ymin = D - 2 * stderr, ymax = D + 2 * stderr))
```

(If you want to more know about data analysis using R, including plotting with
ggplot2, I highly recommend [this](http://r4ds.had.co.nz) free book.)

We can see that all three Africans have $D$ values not significantly different
from 0, meaning that the data is consistent with the null hypothesis of no
Neanderthal ancestry in Africans. On the other hand, the test rejects the null
hypothesis for all non-Africans today, suggesting that Neanderthals admixed
with the ancestors of present-day non-Africans. In fact, this is a similar test
to the one that was used as evidence supporting the Neanderthal admixture
hypothesis in the first place!








## $f_4$ statistic

An alternative way of addressing the previous question is to use the $f_4$
statistic, which is very similar to $D$ statistic and can be calculated as:

$$ f_4 = \frac{\textrm{# BABA sites - # ABBA sites}}{\textrm{# sites}}$$

Again, significant departure of $f_4$ from 0 is informative about gene flow,
in a way analogous to $D$ statistic.

To repeat the previous analysis using $f_4$ statistic, we can run:

```{r f4}
result <- f4(W = pops, X = "Yoruba", Y = "Vindija", Z = "Chimp", prefix = eigenstrat_prefix)
```

```{r eval = FALSE}
head(result)
```

```{r f4_kable, echo = FALSE}
knitr::kable(head(result))
```

We can see by comparing this to the $D$ statistic result above that we can make
the same conclusions.

You might be wondering why we have both $f_4$ and $D$ if they are so similar.
The truth is that $f_4$ is, among other things, directly informative about the
amount of shared genetic drift ("branch length") between pairs of populations,
which is, in many cases, a very useful theoretical property. Other than that,
it's often a matter of personal preference and so `admixr` provides separate
functions for calculating both.









## $f_4$-ratio statistic

Now we know that non-Africans today carry _some_ Neanderthal ancestry. But what if
we want to know _how much_ Neanderthal ancestry they have? What proportion of their
genomes is of Neanderthal origin?

Unfortunately, we don't have enough space here to explain all the details about
the inner workings of $f_4$-ratio statistic. However, in general, when we are
interested in estimating the *proportion* of ancestry in a population $X$
coming some parental lineage $B$, we can use a ratio of two $f_4$ statistics.

$$f_4\textrm{-ratio} = \frac{f_4(A, O; X, C}{f_4(A, O; B, C}.$$

Using `amidxr`, we can calculate $f_4$-ratios using the following code (`X`
being a vector of samples for which we want to estimate Neanderthal ancestry):

```{r f4ratio}
result <- f4ratio(X = pops, A = "Altai", B = "Vindija", C = "Yoruba", O = "Chimp", prefix = eigenstrat_prefix)
```

The ancestry proportion (a number between 0 and 1) is given in the `alpha`
column:

```{r, eval=FALSE}
head(result)
```

```{r f4ratio_kable, echo=FALSE}
knitr::kable(head(result))
```

```{r f4ratio_plot, fig.width = 7, fig.height = 4}
ggplot(result, aes(fct_reorder(X, alpha), alpha, color = abs(Zscore) > 2)) +
  geom_point() +
  geom_errorbar(aes(ymin = alpha - 2 * stderr, ymax = alpha + 2 * stderr)) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(y = "Neandertal ancestry proportion", x = "present-day individual")
```

We can make several observations:

- Again, we don't see any significant Neanderthal ancestry in present-day
  Africans (proportion is consistent with 0%), which is what we confirmed using
  $D$ and $f_4$ above.
- Present-day non-Africans carry between 2-3% of Neanderthal ancestry.
- We see a much higher proportion of Neanderthal ancestry in people from Papua
  New Guinea - more than 4%! This is consistent with earlier studies that
  suggest additional archaic admixture events in the ancestors of present-day
  Papuans.








## $f_3$ statistic

The $f_3$ statistic, also known as the 3-population statistic, is useful
whenever we want to:

1. Estimate the branch length (shared genetic drift) between a pair of
   populations $A$ and $B$ with respect to a common outgroup $C$. In this case,
   the higher the $f_3$ value, the longer the shared evolutionary time between
   $A$ and $B$.
2. Test whether population $C$ is a mixture of two parental populations $A$ and
   $B$. Negative value of the $f_3$ statistic then serves as statistical
   evidence of this admixture.

As an example, imagine we are interested in relative divergence times between
pairs of present-day human populations, and want to know in which approximate
order they split of from each other. To address this problem, we could use
$f_3$ statistic by fixing the $C$ outgroup as Chimp, and calculating pairwise
$f_3$ statistics between all pairs of present-day modern humans.


```{r pops2}
pops <- c("French", "Sardinian", "Han", "Papuan", "Khomani_San", "Mbuti", "Dinka", "Yoruba")

result <- f3(A = pops, B = pops, C = "Chimp", prefix = eigenstrat_prefix)
```

```{r, eval=FALSE}
head(result)
```

```{r f3_kable, echo=FALSE}
knitr::kable(head(result))
```

```{r f3_plot, fig.width = 8, fig.height = 6}
# sort the population labels according to an increasing f3 value relative to French
ordered <- filter(result, A == "French") %>% arrange(f3) %>% .[["B"]] %>% c("French")

# plot heatmap of pairwise f3 values
result %>%
  mutate(A = factor(A, levels = ordered),
         B = factor(B, levels = ordered)) %>%
  ggplot(aes(A, B)) + geom_tile(aes(fill = f3))
```

We can see that when we order the heatmap labels based on values of pairwise
$f_3$ statistics, the (already known) order of population splits pops up
beautifully (i.e. San separated first, followed by Mbuti, etc.).







## qpAdm method

The last ADMIXTOOLS method implemented in `admixr` is qpAdm. Unfortunately, it
is also one that is the most complex and has not been properly described and
peer-reviewed yet. Nevertheless, it seems to have a lot of power to disentangle
complex admixture scenarios, and so we included it in our package as well.

Very briefly, qpAdm can be used to estimate admixture proportions coming from a
series of $N$ source *ancestral* populations, assuming we have reference
populations that form clades with those *source* populations that are closer to
them than to any of the specified *outgroup* populations.

Formally, if a Test population has ancestry coming from $N$ ancestral source
populations, with Reference populations being closer to them than are outgroup
populations $O_i$, we can write:

$$f_4(\textrm{Test}, O_a, O_b, O_c) \approx \sum_{i=1}^N \alpha_i f_4(\textrm{Reference}_i, O_a; O_b, O_c),$$

where $\sum_{i=1}^N \alpha_i = 1$ and $\alpha_i \geq 1$ for all $i = 1, ..., N$.

If this looks like black magic to you, I feel your pain and direct you to the
Supplementary Section 9 of [Haak et al.
2015](http://www.nature.com/articles/nature14317), and an [informal
write-up](https://github.com/DReichLab/AdmixTools/blob/master/pdoc.pdf)
distributed with the ADMIXTOOLS software. While the method does not have a
dedicated paper yet, it's not so complicated to understand the basic
principles.

Probably the simplest possible case to show that qpAdm works is by returning
to the question of estimating Neanderthal ancestry proportions. Let's define:

- Europeans as the *target* samples to estimate ancestry proportions for
- Vindija Neanderthal and an African as two *reference* populations (two
  potential sources of ancestries in Europeans today)
- *outgroup* populations - Chimp, Altai Neanderthal and Denisovan (which are
  all further from the true ancestral populations - Vindija and African - than
  the *reference* populations)

Assuming all of that, we can run qpAdm with:

```{r qpAdm}
result <- qpAdm(
  target = c("French", "Sardinian", "Mbuti", "Dinka"),
  references = c("Vindija", "Yoruba"),
  outgroups = c("Chimp", "Denisova", "Altai"),
  prefix = eigenstrat_prefix
)
```

```{r, eval=FALSE}
result
```

```{r qpAdm_kable, echo=FALSE}
knitr::kable(result)
```

If we compare this result to the $f_4$-ratio values calculated above, we see
that the qpAdm estimates are very close to what we got earlier.








## Merging population labels

What we've been doing so far was calculating statistics for individual samples.
However, it is often useful to treat multiple samples as a single group or
population. `admixr` provides a function called `group_labels` that does just
that.

Here is an example: let's say we want to run a similar analysis to the one
described in the $D$ statistic section, but we want to treat Europeans,
Africans and archaics combined populations. But the `ind` file that we have
does not contain grouped labels - each sample stands on its own:

```{r orig_ind, echo = FALSE, comment = ""}
ind_path <- paste0(eigenstrat_prefix, ".ind")
cat(system(paste0("column -t ", ind_path), intern = TRUE), sep = "\n")
```

To merge several individual samples under a combined label we can call
`group_labels` like this:

```{r group_labels}
# paths to the original ind file and a new modified ind file, which will
# contain merged population labels
ind_path <- paste0(eigenstrat_prefix, ".ind")
modif_path <- tempfile()

group_labels(
  ind = ind_path,
  modified_ind = modif_path,
  labels = list( # new population labels
    European = c("French", "Sardinian"),
    African = c("Dinka", "Yoruba", "Mbuti", "Khomani_San"),
    Archaic = c("Vindija", "Altai", "Denisova")
  )
)
```

This is what a modified `ind` file generated by `group_labels` looks like:

```{r modif_ind, echo = FALSE, comment = ""}
cat(system(paste0("column -t ", modif_path), intern = TRUE), sep = "\n")
```

We can then use "European", "African" and "Archaic" labels in any of the
`admixr` wrapper functions described above, we just have to specify a new `ind`
file in addition to the `prefix` argument. For example:

```{r modif_d}
result <- d(W = "European", X = "African", Y = "Archaic", Z = "Chimp",
            prefix = eigenstrat_prefix, ind = modif_path)
```

Here is the result, showing (as we've seen above for individual samples) that
Europeans show genetic affinity to archaic humans compared to Africans today:

```{r eval = FALSE}
head(result)
```

```{r modif_d_kable, echo = FALSE}
knitr::kable(head(result))
```

Note that in the `d()` call we provided both path to shared EIGENSTRAT prefix,
but we also specified the path to the modified `ind` file separately. This overides
the unmodified `ind` file that would be normally used, and ADMIXTOOLS picks up
the combined population labels from the modified `ind` file.









## Merging EIGENSTRAT datasets

Another useful data processing function is `merge_eigenstrat`. This function
takes two EIGENSTRAT datasets (i.e. trios of ind/snp/geno files) and merges
them, producing a union of samples and intersection of SNPs from both of them.

```{r merge_eigenstrat, eval = FALSE}
# this is just an example code - it will not run unless you specify the paths
merge_eigenstrat(
    prefix = output_prefix,       # prefix of the final combined dataset
    input1 = path_to_1st_dataset, # prefix of the first dataset
    input2 = path_to_2nd_dataset  # prefix of the first dataset
)
```








## Counting present/missing SNPs

The `count_snps` function can be useful for quality control, weighting of
admixture statistics ($D$, $f_4$, etc.) for regression analyses etc. There are
two optional arguments:

- `prop` - changes whether to report SNP counts or proportions (set to `FALSE`
  by default),
- `missing` - controls whether to count missing SNPs instead of present SNPs
  (set to `FALSE` by default).

For each sample, count the SNPs present in that sample:
```{r present_snps, results = "hide"}
count_snps(eigenstrat_prefix)
```

```{r present_snps_kable, echo = FALSE}
knitr::kable(count_snps(eigenstrat_prefix))
```








## Data filtering




### Filtering based on a BED file

A common situation in genomics is performing an analysis on a subset of the
genome.  However, EIGENSTRAT is a rather obscure file format which makes it
very difficult to find bioinformatics tools that support it. Luckily, `admixr`
includes a function `filter_sites()` that takes an EIGENSTRAT prefix and a BED
file and produces a snp file, that contains simply contains positions of sites
that either overlap (or don't overlap) regions/sites specified in the BED file.

Why is that useful? Each of the main `admixr` functions accepts an `exclude = `
argument, which specifies a path to a snp file with positions of we want to
exclude from our analysis. This is file is exactly what `filter_sites()`
function generates.

This might seem like a very convoluted way to do this type of analysis but this
is how ADMIXTOOLS actually works under the hood, and being "just" a wrapper
around ADMIXTOOLS we have no other choice but to comply. There is a rather
obscure option called
[`badsnpfile`](https://github.com/DReichLab/AdmixTools/blob/master/README.ROLLOFF#L48),
which specifies the sites to exclude from the calculation. The `exclude = `
argument of `admixr` functions simply fills in the `badsnpfile` parameter
before starting an ADMIXTOOLS command.

(An alternative to this way of filtering data would be to create a whole new
EIGENSTRAT snp/geno/ind trio for each new subset. However, this is problematic
if the data set is huge, or if we need to repeat an analysis on many different
subsets of data. In my experience, I found that generating just a snp file
instead of creating a new subset of the complete data is a good compromise. If
you really think this package should implement this alternative, please get in
touch and we can talk about it.)

Here are two examples how to filter EIGENSTRAT data (just for illustration,
they will not run by themselves without specifying all the paths):

```{r, eval = FALSE}
# run this if your BED file contains regions to keep in an analysis
filter_sites(prefix = eigenstrat_prefix, bed = regions_to_include, outsnp = excluded_snps1)

# run this if your BED file contains regions to remove from an analysis
filter_sites(prefix = eigenstrat_prefix, bed = regions_to_exclude, outsnp = excluded_snps2)
```
Both commands do a different thing, but both generate a snp file that specifies
which sites need to be excluded from an analysis. It can be used in this way:

```{r, eval = FALSE}
d(pop_W, pop_X, pop_Y, pop_Z, prefix = eigenstrat_prefix, exclude = excluded_snps1)
```





### Filtering out potential ancient DNA damage SNPs

In an ancient DNA world, we often need to repeat an analysis on a subset of
data that is less likely to be influenced by ancient DNA damage, to verify that
our results are not caused by artifacts in the data (due to biochemical
properties of DNA degradation, ancient DNA damage will lead to an increase in
C&rightarrow;T and G&rightarrow;A substitutions). Using a similar method
described in a general BED filtering section above, we can use the
`filter_damage()` function to generate a snp file with positions that carry
transitions (C&rightarrow;T and G&rightarrow;A sites), that can be removed
using the `exclude = ` argument of the main `admixr` functions.

```{r, eval = FALSE}
# generate snp file with positions of transitions
transitions <- tempfile()
filter_damage(prefix = eigenstrat_prefix, outsnp = transitions)

# perform the calculation only on transversions
d(W = "French", X = "Dinka", Y = "Altai", Z = "Chimp", prefix = eigenstrat_prefix, exclude = transitions)
```
